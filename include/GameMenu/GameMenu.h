/*
*	Copyright (C) 2016 Sidhin S Thomas
*
*	This software is licensed under the MIT License
*/

#ifndef SS_USER_INTERFACE
#define SS_USER_INTERFACE


/*--- Headers ---*/
#include <SFML/Graphics.hpp>
#include <memory>
namespace gmenu {

	
	/* Simple abstract class interface to implement Actions */
	class Action {
	public:
		/* The function that will be called by the menu
		Depending on the return value of start() the menu will close
		- If start() return true : menu will not close
		- If start() return false: menu will close

		usefull when you need to implement a feature after which it should not return to the menu.
		eg. Back/Exit/Game Mode etc.
		*/
		virtual bool start() = 0;
	};

	struct MenuItem {
		std::shared_ptr<Action> action;
		std::string title;
	};

	/* BitFlags for Different possible Layouts */
	enum Layout {

		TitleCentre = 1 << 0,
		TitleRight = 1 << 1,
		TitleLeft = 1 << 2,

		ItemCentre = 1 << 3,
		ItemRight = 1 << 4,
		ItemLeft = 1 << 5,

		Default = TitleCentre | ItemCentre,
					  
	};

	/* Defines the style of the menu */
	struct Style {
		sf::Font &TitleFont;
		sf::Font &ItemFont;

		sf::Color TitleColor = sf::Color::Green;;
		sf::Color ItemColor = sf::Color::Red ;
		sf::Color Selected = sf::Color::Blue;

		unsigned int TitleFontSize = 50;
		unsigned int ItemFontSize = 20;

		float MenuTitleScaleFactor = 1.25;
		float MenuItemScaleFactor = 0.25;

		struct {
			signed int top, left;
		} PaddingItems, PaddingTitle;

		int layout = Layout::Default;
		Style(sf::Font &mf, sf::Font &itmf):
			TitleFont( mf ), ItemFont( itmf ), PaddingTitle {10,0}, PaddingItems {0,0}
		{	
		}
	};


	
	
	class Menu {
		/* Generic Menu - can be instantiated to generate a custom menu as needed over a sf::RenderWindow */

	public:
		
		/* Only available constructor */
		Menu(sf::RenderWindow &wnd, std::string title, std::vector<MenuItem> items, Style &st):
			style( st ), window (wnd) {
			menuTitle = title;
			menuItems = items;
		}

	    /* This method is will start the menu and handover the screen control to it.
		The Event loop will be controlled by this function after the call, and 
		only after Back/exit on the menu will the control be returned.

		The control is returned when an "gmenu::Action" object is called
		whose start return "false" */
		void createMenu();

		/* In case menu items needs to be changed */
		void setMenuItems( std::vector<MenuItem> );
		
		/* In case the title needs to be changed */
		void setTitle(std::string title);
		

	private:
		

		void writeText( std::string string, sf::Font font, unsigned int size, float x, float y,
			const sf::Color &color);

		void setMenu();

		void drawMenu();


		/*==================================================*
		*				Internal structuers        			*
		*===================================================*/

		std::vector<MenuItem> menuItems;

		struct coordinates {
			float x = 0;
			float y = 0;
		}  title_location;
		std::vector<coordinates> item_location;

		/*==================================================*
		*					Data Members					*
		*===================================================*/

		int currently_selected_item = 0;

		Style &style;
		
		sf::RenderWindow &window;
		std::string menuTitle;		

	}; // Menu


	/*==================================================*
	*				Operator overload					*
	*===================================================*/
	template<class T> inline T operator~ ( T a ) {
		return (T) ~(int) a;
	}
	template<class T> inline T operator| ( T a, T b ) {
		return (T) ((int) a | (int) b);
	}
	template<class T> inline T operator& ( T a, T b ) {
		return (T) ((int) a & (int) b);
	}
	template<class T> inline T operator^ ( T a, T b ) {
		return (T) ((int) a ^ (int) b);
	}
	template<class T> inline T& operator|= ( T& a, T b ) {
		return (T&) ((int&) a |= (int) b);
	}
	template<class T> inline T& operator&= ( T& a, T b ) {
		return (T&) ((int&) a &= (int) b);
	}
	template<class T> inline T& operator^= ( T& a, T b ) {
		return (T&) ((int&) a ^= (int) b);
	}


} // namespace gmenu

#endif